{"version":3,"file":"data.js","sources":["../../../../../admin/src/pages/EditView/utils/data.ts"],"sourcesContent":["import { createRulesEngine } from '@strapi/admin/strapi-admin';\nimport { generateNKeysBetween } from 'fractional-indexing';\nimport pipe from 'lodash/fp/pipe';\n\nimport { DOCUMENT_META_FIELDS } from '../../../constants/attributes';\n\nimport type { ComponentsDictionary, Document } from '../../../hooks/useDocument';\nimport type { Schema, UID } from '@strapi/types';\n\n/* -------------------------------------------------------------------------------------------------\n * traverseData\n * -----------------------------------------------------------------------------------------------*/\n\n// Make only attributes required since it's the only one Content History has\ntype PartialSchema = Partial<Schema.Schema> & Pick<Schema.Schema, 'attributes'>;\n\ntype Predicate = <TAttribute extends Schema.Attribute.AnyAttribute>(\n  attribute: TAttribute,\n  value: Schema.Attribute.Value<TAttribute>\n) => boolean;\ntype Transform = <TAttribute extends Schema.Attribute.AnyAttribute>(\n  value: any,\n  attribute: TAttribute\n) => any;\ntype AnyData = Omit<Document, 'id'>;\n\nconst BLOCK_LIST_ATTRIBUTE_KEYS = ['__component', '__temp_key__'];\n\n/**\n * @internal\n * @description Returns the direct parent object for a dot-separated path.\n */\nconst getDirectParent = (data: unknown, path: string): unknown => {\n  if (!path) return undefined;\n  const isNumericIndex = (value: string) => /^\\d+$/.test(value);\n  const segments = path.split('.');\n  const parentPath = segments.slice(0, -1);\n  let current: unknown = data;\n\n  for (const segment of parentPath) {\n    if (current == null) return undefined;\n\n    if (isNumericIndex(segment)) {\n      if (!Array.isArray(current)) return undefined;\n      current = current[Number(segment)];\n      continue;\n    }\n\n    if (typeof current !== 'object') return undefined;\n    current = (current as Record<string, unknown>)[segment];\n  }\n\n  return current;\n};\n\n/**\n * @internal This function is used to traverse the data and transform the values.\n * Given a predicate function, it will transform the value (using the given transform function)\n * if the predicate returns true. If it finds that the attribute is a component or dynamiczone,\n * it will recursively traverse those data structures as well.\n *\n * It is possible to break the ContentManager by using this function incorrectly, for example,\n * if you transform a number into a string but the attribute type is a number, the ContentManager\n * will not be able to save the data and the Form will likely crash because the component it's\n * passing the data too won't succesfully be able to handle the value.\n */\nconst traverseData =\n  (predicate: Predicate, transform: Transform) =>\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  (data: AnyData = {}) => {\n    const traverse = (datum: AnyData, attributes: Schema.Schema['attributes']) => {\n      return Object.entries(datum).reduce<AnyData>((acc, [key, value]) => {\n        const attribute = attributes[key];\n\n        /**\n         * If the attribute is a block list attribute, we don't want to transform it.\n         * We also don't want to transform null or undefined values.\n         */\n        if (BLOCK_LIST_ATTRIBUTE_KEYS.includes(key) || value === null || value === undefined) {\n          acc[key] = value;\n          return acc;\n        }\n\n        if (attribute.type === 'component') {\n          if (attribute.repeatable) {\n            const componentValue = (\n              predicate(attribute, value) ? transform(value, attribute) : value\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n            acc[key] = componentValue.map((componentData) =>\n              traverse(componentData, components[attribute.component]?.attributes ?? {})\n            );\n          } else {\n            const componentValue = (\n              predicate(attribute, value) ? transform(value, attribute) : value\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, false>>;\n\n            acc[key] = traverse(componentValue, components[attribute.component]?.attributes ?? {});\n          }\n        } else if (attribute.type === 'dynamiczone') {\n          const dynamicZoneValue = (\n            predicate(attribute, value) ? transform(value, attribute) : value\n          ) as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n          acc[key] = dynamicZoneValue.map((componentData) =>\n            traverse(componentData, components[componentData.__component]?.attributes ?? {})\n          );\n        } else if (predicate(attribute, value)) {\n          acc[key] = transform(value, attribute);\n        } else {\n          acc[key] = value;\n        }\n\n        return acc;\n      }, {});\n    };\n\n    return traverse(data, schema.attributes);\n  };\n\n/* -------------------------------------------------------------------------------------------------\n * removeProhibitedFields\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal Removes all the fields that are not allowed.\n */\nconst removeProhibitedFields = (prohibitedFields: Schema.Attribute.Kind[]) =>\n  traverseData(\n    (attribute) => prohibitedFields.includes(attribute.type),\n    () => ''\n  );\n\n/* -------------------------------------------------------------------------------------------------\n * prepareRelations\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Sets all relation values to an empty array.\n */\nconst prepareRelations = traverseData(\n  (attribute) => attribute.type === 'relation',\n  () => ({\n    connect: [],\n    disconnect: [],\n  })\n);\n\n/* -------------------------------------------------------------------------------------------------\n * prepareTempKeys\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Adds a `__temp_key__` to each component and dynamiczone item. This gives us\n * a stable identifier regardless of its ids etc. that we can then use for drag and drop.\n */\nconst prepareTempKeys = traverseData(\n  (attribute) =>\n    (attribute.type === 'component' && attribute.repeatable) || attribute.type === 'dynamiczone',\n  (data) => {\n    if (Array.isArray(data) && data.length > 0) {\n      const keys = generateNKeysBetween(undefined, undefined, data.length);\n\n      return data.map((datum, index) => ({\n        ...datum,\n        __temp_key__: keys[index],\n      }));\n    }\n\n    return data;\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * removeFieldsThatDontExistOnSchema\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Fields that don't exist in the schema like createdAt etc. are only on the first level (not nested),\n * as such we don't need to traverse the components to remove them.\n */\nconst removeFieldsThatDontExistOnSchema = (schema: PartialSchema) => (data: AnyData) => {\n  const schemaKeys = Object.keys(schema.attributes);\n  const dataKeys = Object.keys(data);\n\n  const keysToRemove = dataKeys.filter((key) => !schemaKeys.includes(key));\n\n  const revisedData = [...keysToRemove, ...DOCUMENT_META_FIELDS].reduce((acc, key) => {\n    delete acc[key];\n\n    return acc;\n  }, structuredClone(data));\n\n  return revisedData;\n};\n\n/**\n * @internal\n * @description We need to remove null fields from the data-structure because it will pass it\n * to the specific inputs breaking them as most would prefer empty strings or `undefined` if\n * they're controlled / uncontrolled. However, Boolean fields should preserve null values.\n */\nconst removeNullValues = (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  traverseData(\n    (attribute, value) => value === null && attribute.type !== 'boolean',\n    () => undefined\n  )(schema, components);\n\n/* -------------------------------------------------------------------------------------------------\n * transformDocuments\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Takes a document data structure (this could be from the API or a default form structure)\n * and applies consistent data transformations to it. This is also used when we add new components to the\n * form to ensure the data is correctly prepared from their default state e.g. relations are set to an empty array.\n */\nconst transformDocument =\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  (document: AnyData) => {\n    const transformations = pipe(\n      removeFieldsThatDontExistOnSchema(schema),\n      removeProhibitedFields(['password'])(schema, components),\n      removeNullValues(schema, components),\n      prepareRelations(schema, components),\n      prepareTempKeys(schema, components)\n    );\n\n    return transformations(document);\n  };\n\ntype HandleOptions = {\n  schema?: Schema.ContentType | Schema.Component;\n  initialValues?: AnyData;\n  components?: Record<string, Schema.Component>;\n};\n\ntype RemovedFieldPath = string;\n\n/**\n * @internal\n * @description Finds the initial value for a component or dynamic zone item (based on its __temp_key__ and not its index).\n * @param initialValue - The initial values object.\n * @param item - The item to find the initial value for.\n * @returns The initial value for the item.\n */\nconst getItemInitialValue = (initialValue: AnyData, item: AnyData) => {\n  if (initialValue && Array.isArray(initialValue)) {\n    const matchingInitialItem = initialValue.find(\n      (initialItem) => initialItem.__temp_key__ === item.__temp_key__\n    );\n    if (matchingInitialItem) {\n      return matchingInitialItem;\n    }\n  }\n  return {};\n};\n\n/**\n * @internal\n * @description Collects paths of attributes that should be removed based on visibility conditions.\n * This function only evaluates conditions.visible (JSON Logic), not the visible boolean property.\n *\n * @param data - The data object to evaluate\n * @param schema - The content type schema\n * @param components - Dictionary of component schemas\n * @param path - Current path in the data structure (for nested components/dynamiczones)\n * @returns Array of field paths that should be removed\n */\nconst collectInvisibleAttributes = (\n  data: AnyData,\n  schema: Schema.ContentType | Schema.Component | undefined,\n  components: Record<string, Schema.Component>,\n  path: string[] = []\n): RemovedFieldPath[] => {\n  if (!schema?.attributes) return [];\n\n  const rulesEngine = createRulesEngine();\n  const removedPaths: RemovedFieldPath[] = [];\n  const evaluatedData: AnyData = {};\n\n  for (const [attrName, attrDef] of Object.entries(schema.attributes)) {\n    const fullPath = [...path, attrName].join('.');\n\n    // Skip fields with visible: false - they're managed by backend\n    if ('visible' in attrDef && attrDef.visible === false) {\n      continue;\n    }\n\n    const condition = attrDef?.conditions?.visible;\n    const isVisible = condition\n      ? rulesEngine.evaluate(condition, { ...data, ...evaluatedData })\n      : true;\n\n    if (!isVisible) {\n      removedPaths.push(fullPath);\n      continue;\n    }\n\n    // Track this field for future condition evaluations\n    if (attrName in data) {\n      evaluatedData[attrName] = data[attrName];\n    }\n\n    // Recursively process components\n    if (attrDef.type === 'component') {\n      const compSchema = components[attrDef.component];\n      const value = data[attrName];\n\n      if (attrDef.repeatable && Array.isArray(value)) {\n        value.forEach((item) => {\n          const nestedPaths = collectInvisibleAttributes(item, compSchema, components, [\n            ...path,\n            `${attrName}[${item.__temp_key__}]`,\n          ]);\n          removedPaths.push(...nestedPaths);\n        });\n      } else if (value && typeof value === 'object') {\n        const nestedPaths = collectInvisibleAttributes(value, compSchema, components, [\n          ...path,\n          attrName,\n        ]);\n        removedPaths.push(...nestedPaths);\n      }\n    }\n\n    // Recursively process dynamic zones\n    if (attrDef.type === 'dynamiczone' && Array.isArray(data[attrName])) {\n      data[attrName].forEach((dzItem: AnyData) => {\n        const compUID = dzItem?.__component;\n        const compSchema = components[compUID];\n        const nestedPaths = collectInvisibleAttributes(dzItem, compSchema, components, [\n          ...path,\n          `${attrName}[${dzItem.__temp_key__}]`,\n        ]);\n        removedPaths.push(...nestedPaths);\n      });\n    }\n  }\n\n  return removedPaths;\n};\n\n/**\n * @internal\n * @description Removes attributes from data based on the list of paths to remove.\n * Preserves fields with visible: false from data or initialValues.\n *\n * @param data - The data object to filter\n * @param initialValues - Initial values to fall back to\n * @param schema - The content type schema\n * @param components - Dictionary of component schemas\n * @param removedPaths - Array of field paths to remove\n * @param currentPath - Current path in the data structure\n * @returns Filtered data object\n */\nconst filterDataByRemovedPaths = (\n  data: AnyData,\n  initialValues: AnyData,\n  schema: Schema.ContentType | Schema.Component | undefined,\n  components: Record<string, Schema.Component>,\n  removedPaths: RemovedFieldPath[],\n  currentPath: string[] = []\n): AnyData => {\n  if (!schema?.attributes) return data;\n\n  const result: AnyData = {};\n\n  for (const [attrName, attrDef] of Object.entries(schema.attributes)) {\n    const fullPath = [...currentPath, attrName].join('.');\n\n    // Check if this field should be removed\n    if (removedPaths.includes(fullPath)) {\n      continue;\n    }\n\n    // Handle fields with visible: false - preserve from data or initialValues\n    if ('visible' in attrDef && attrDef.visible === false) {\n      const userProvided = Object.hasOwn(data, attrName);\n      if (userProvided) {\n        result[attrName] = data[attrName];\n      } else if (attrName in initialValues) {\n        result[attrName] = initialValues[attrName];\n      }\n      continue;\n    }\n\n    const userProvided = Object.hasOwn(data, attrName);\n    const currentValue = userProvided ? data[attrName] : undefined;\n    const initialValue = initialValues?.[attrName];\n\n    // Handle components\n    if (attrDef.type === 'component') {\n      const compSchema = components[attrDef.component];\n      const value = currentValue === undefined ? initialValue : currentValue;\n\n      if (!value) {\n        result[attrName] = attrDef.repeatable ? [] : null;\n        continue;\n      }\n\n      if (attrDef.repeatable && Array.isArray(value)) {\n        result[attrName] = value.map((item) => {\n          const componentInitialValue = getItemInitialValue(initialValue, item);\n          return filterDataByRemovedPaths(\n            item,\n            componentInitialValue,\n            compSchema,\n            components,\n            removedPaths,\n            [...currentPath, `${attrName}[${item.__temp_key__}]`]\n          );\n        });\n      } else {\n        result[attrName] = filterDataByRemovedPaths(\n          value,\n          initialValue ?? {},\n          compSchema,\n          components,\n          removedPaths,\n          [...currentPath, attrName]\n        );\n      }\n\n      continue;\n    }\n\n    // Handle dynamic zones\n    if (attrDef.type === 'dynamiczone') {\n      if (!Array.isArray(currentValue)) {\n        result[attrName] = [];\n        continue;\n      }\n\n      result[attrName] = currentValue.map((dzItem) => {\n        const compUID = dzItem?.__component;\n        const compSchema = components[compUID];\n        const componentInitialValue = getItemInitialValue(initialValue, dzItem);\n\n        const cleaned = filterDataByRemovedPaths(\n          dzItem,\n          componentInitialValue,\n          compSchema,\n          components,\n          removedPaths,\n          [...currentPath, `${attrName}[${dzItem.__temp_key__}]`]\n        );\n\n        // For newly created components, ensure id is undefined (in case of reordering)\n        const processedItem =\n          dzItem.id === undefined || dzItem.id === null\n            ? { __component: compUID, ...cleaned, id: undefined }\n            : { __component: compUID, ...cleaned };\n\n        return processedItem;\n      });\n\n      continue;\n    }\n\n    // Regular fields - preserve from data or initialValues\n    if (currentValue !== undefined) {\n      result[attrName] = currentValue;\n    } else if (initialValue !== undefined) {\n      result[attrName] = initialValue;\n    }\n  }\n\n  // Pass through any fields from data that aren't in the schema\n  for (const [key, value] of Object.entries(data)) {\n    if (!(key in result) && !(key in (schema?.attributes || {}))) {\n      result[key] = value;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Removes values from the data object if their corresponding attribute has a\n * visibility condition that evaluates to false.\n *\n * @param data - The data object to filter based on visibility\n * @param options - Schema, initialValues, and components\n * @returns Object with filtered data and list of removed attribute paths\n */\nconst handleInvisibleAttributes = (\n  data: AnyData,\n  { schema, initialValues = {}, components = {} }: HandleOptions\n): {\n  data: AnyData;\n  removedAttributes: RemovedFieldPath[];\n} => {\n  if (!schema?.attributes) return { data, removedAttributes: [] };\n\n  const removedAttributes = collectInvisibleAttributes(data, schema, components);\n\n  const filteredData = filterDataByRemovedPaths(\n    data,\n    initialValues,\n    schema,\n    components,\n    removedAttributes\n  );\n\n  return {\n    data: filteredData,\n    removedAttributes,\n  };\n};\n\nexport {\n  removeProhibitedFields,\n  prepareRelations,\n  prepareTempKeys,\n  removeFieldsThatDontExistOnSchema,\n  transformDocument,\n  handleInvisibleAttributes,\n  getDirectParent,\n};\nexport type { AnyData };\n"],"names":["BLOCK_LIST_ATTRIBUTE_KEYS","getDirectParent","data","path","undefined","isNumericIndex","value","test","segments","split","parentPath","slice","current","segment","Array","isArray","Number","traverseData","predicate","transform","schema","components","traverse","datum","attributes","Object","entries","reduce","acc","key","attribute","includes","type","repeatable","componentValue","map","componentData","component","dynamicZoneValue","__component","removeProhibitedFields","prohibitedFields","prepareRelations","connect","disconnect","prepareTempKeys","length","keys","generateNKeysBetween","index","__temp_key__","removeFieldsThatDontExistOnSchema","schemaKeys","dataKeys","keysToRemove","filter","revisedData","DOCUMENT_META_FIELDS","structuredClone","removeNullValues","transformDocument","document","transformations","pipe","getItemInitialValue","initialValue","item","matchingInitialItem","find","initialItem","collectInvisibleAttributes","rulesEngine","createRulesEngine","removedPaths","evaluatedData","attrName","attrDef","fullPath","join","visible","condition","conditions","isVisible","evaluate","push","compSchema","forEach","nestedPaths","dzItem","compUID","filterDataByRemovedPaths","initialValues","currentPath","result","userProvided","hasOwn","currentValue","componentInitialValue","cleaned","processedItem","id","handleInvisibleAttributes","removedAttributes","filteredData"],"mappings":"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"}