{"version":3,"file":"components.js","sources":["../../../server/src/services/components.ts"],"sourcesContent":["import { isNil, mapValues } from 'lodash/fp';\n\nimport type { UID, Struct, Core } from '@strapi/types';\nimport type { Configuration } from '../../../shared/contracts/content-types';\nimport type { ConfigurationUpdate } from './configuration';\n\nimport { getService } from '../utils';\nimport storeUtils from './utils/store';\nimport createConfigurationService from './configuration';\n\nconst STORE_KEY_PREFIX = 'components';\n\nconst configurationService = createConfigurationService({\n  storeUtils,\n  isComponent: true,\n  prefix: STORE_KEY_PREFIX,\n  getModels() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return mapValues(toContentManagerModel, strapi.components);\n  },\n});\n\nexport default ({ strapi }: { strapi: Core.Strapi }) => ({\n  findAllComponents() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return Object.values(strapi.components).map(toContentManagerModel);\n  },\n\n  findComponent(uid: UID.Component) {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    const component = strapi.components[uid];\n\n    return isNil(component) ? component : toContentManagerModel(component);\n  },\n\n  async findConfiguration(component: Struct.ComponentSchema) {\n    const configuration: Configuration = await configurationService.getConfiguration(component.uid);\n\n    return {\n      uid: component.uid,\n      category: component.category,\n      ...configuration,\n    };\n  },\n\n  async updateConfiguration(\n    component: Struct.ComponentSchema,\n    newConfiguration: ConfigurationUpdate\n  ) {\n    await configurationService.setConfiguration(component.uid, newConfiguration);\n\n    return this.findConfiguration(component);\n  },\n\n  /**\n   * Batch load component configurations.\n   *\n   * Collects all component UIDs upfront, then loads configurations in a single\n   * batch query instead of sequential queries per component.\n   */\n  async findComponentsConfigurations(model: Struct.ComponentSchema) {\n    // Cache on request state so the same request can reuse configs\n    const requestState = strapi.requestContext?.get?.()?.state as\n      | { __componentsConfigurationsCache?: Map<string, Record<string, Configuration>> }\n      | undefined;\n    const requestCache = requestState?.__componentsConfigurationsCache;\n\n    const componentUids = new Set<UID.Component>();\n\n    const collectComponentUids = (schema: Struct.ComponentSchema) => {\n      for (const key of Object.keys(schema.attributes)) {\n        const attribute = schema.attributes[key];\n\n        if (attribute.type === 'component') {\n          const uid = attribute.component;\n          if (!componentUids.has(uid)) {\n            componentUids.add(uid);\n            const nestedComponent = this.findComponent(uid);\n            if (nestedComponent) {\n              collectComponentUids(nestedComponent);\n            }\n          }\n        }\n\n        if (attribute.type === 'dynamiczone') {\n          for (const uid of attribute.components) {\n            if (!componentUids.has(uid)) {\n              componentUids.add(uid);\n              const nestedComponent = this.findComponent(uid);\n              if (nestedComponent) {\n                collectComponentUids(nestedComponent);\n              }\n            }\n          }\n        }\n      }\n    };\n\n    collectComponentUids(model);\n\n    if (componentUids.size === 0) {\n      return {};\n    }\n\n    // Key format must match configuration.ts uidToStoreKey: `${prefix}::${uid}`\n    const uidsArray = Array.from(componentUids);\n    const prefixedKeys = uidsArray.map((uid) => `components::${uid}`);\n    const cacheKey = prefixedKeys.slice().sort().join('|');\n    if (requestCache?.has(cacheKey)) {\n      return requestCache.get(cacheKey)! as Record<\n        string,\n        Configuration & { category: string; isComponent: boolean }\n      >;\n    }\n\n    const configs = await storeUtils.getModelConfigurations(prefixedKeys);\n\n    const componentsMap: Record<\n      string,\n      Configuration & { category: string; isComponent: boolean }\n    > = {};\n\n    for (const uid of uidsArray) {\n      const component = this.findComponent(uid);\n      const configKey = `components::${uid}`;\n      // Fallback must include proper layouts structure for frontend compatibility\n      const configuration = configs[configKey] || {\n        settings: {},\n        metadatas: {},\n        layouts: { list: [], edit: [] },\n      };\n\n      componentsMap[uid] = {\n        uid: component.uid,\n        category: component.category,\n        ...configuration,\n      };\n    }\n\n    if (requestState) {\n      if (!requestState.__componentsConfigurationsCache) {\n        requestState.__componentsConfigurationsCache = new Map();\n      }\n      requestState.__componentsConfigurationsCache.set(cacheKey, componentsMap);\n    }\n\n    return componentsMap;\n  },\n\n  syncConfigurations() {\n    return configurationService.syncConfigurations();\n  },\n});\n"],"names":["STORE_KEY_PREFIX","configurationService","createConfigurationService","storeUtils","isComponent","prefix","getModels","toContentManagerModel","getService","mapValues","strapi","components","findAllComponents","Object","values","map","findComponent","uid","component","isNil","findConfiguration","configuration","getConfiguration","category","updateConfiguration","newConfiguration","setConfiguration","findComponentsConfigurations","model","requestState","requestContext","get","state","requestCache","__componentsConfigurationsCache","componentUids","Set","collectComponentUids","schema","key","keys","attributes","attribute","type","has","add","nestedComponent","size","uidsArray","Array","from","prefixedKeys","cacheKey","slice","sort","join","configs","getModelConfigurations","componentsMap","configKey","settings","metadatas","layouts","list","edit","Map","set","syncConfigurations"],"mappings":"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"}