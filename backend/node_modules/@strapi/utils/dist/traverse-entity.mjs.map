{"version":3,"file":"traverse-entity.mjs","sources":["../src/traverse-entity.ts"],"sourcesContent":["import { clone, isObject, isArray, isNil, curry } from 'lodash/fp';\n\nimport type { Attribute, AnyAttribute, Model, Data } from './types';\nimport { isRelationalAttribute, isMediaAttribute } from './content-types';\n\n/**\n * Execute promises in parallel but throw errors in array index order.\n */\nconst parallelWithOrderedErrors = async <T>(promises: Promise<T>[]): Promise<T[]> => {\n  const results = await Promise.allSettled(promises);\n\n  // Throw first error in array index order (matches sequential behavior)\n  for (let i = 0; i < results.length; i += 1) {\n    const result = results[i];\n    if (result.status === 'rejected') {\n      throw result.reason;\n    }\n  }\n\n  return results.map((r) => (r as PromiseFulfilledResult<T>).value);\n};\n\nexport type VisitorUtils = ReturnType<typeof createVisitorUtils>;\n\nexport interface VisitorOptions {\n  data: Record<string, unknown>;\n  schema: Model;\n  key: string;\n  value: Data[keyof Data];\n  attribute?: AnyAttribute;\n  path: Path;\n  getModel(uid: string): Model;\n  parent?: Parent;\n}\n\nexport type Visitor = (visitorOptions: VisitorOptions, visitorUtils: VisitorUtils) => void;\n\nexport interface Path {\n  raw: string | null;\n  attribute: string | null;\n  rawWithIndices?: string | null;\n}\n\nexport interface TraverseOptions {\n  schema: Model;\n  path?: Path;\n  parent?: Parent;\n  getModel(uid: string): Model;\n}\n\nexport interface Parent {\n  attribute?: Attribute;\n  key: string | null;\n  path: Path;\n  schema: Model;\n}\n\nconst traverseEntity = async (visitor: Visitor, options: TraverseOptions, entity: Data) => {\n  const { path = { raw: null, attribute: null, rawWithIndices: null }, schema, getModel } = options;\n\n  let parent = options.parent;\n\n  const traverseMorphRelationTarget = async (visitor: Visitor, path: Path, entry: Data) => {\n    const targetSchema = getModel(entry.__type!);\n\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  const traverseRelationTarget =\n    (schema: Model) => async (visitor: Visitor, path: Path, entry: Data) => {\n      const traverseOptions: TraverseOptions = { schema, path, getModel, parent };\n\n      return traverseEntity(visitor, traverseOptions, entry);\n    };\n\n  const traverseMediaTarget = async (visitor: Visitor, path: Path, entry: Data) => {\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  const traverseComponent = async (visitor: Visitor, path: Path, schema: Model, entry: Data) => {\n    const traverseOptions: TraverseOptions = { schema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  const visitDynamicZoneEntry = async (visitor: Visitor, path: Path, entry: Data) => {\n    const targetSchema = getModel(entry.__component!);\n    const traverseOptions: TraverseOptions = { schema: targetSchema, path, getModel, parent };\n\n    return traverseEntity(visitor, traverseOptions, entry);\n  };\n\n  // End recursion\n  if (!isObject(entity) || isNil(schema)) {\n    return entity;\n  }\n\n  // Don't mutate the original entity object\n  // only clone at 1st level as the next level will get clone when traversed\n  const copy = clone(entity);\n  const visitorUtils = createVisitorUtils({ data: copy });\n\n  const keys = Object.keys(copy);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    // Retrieve the attribute definition associated to the key from the schema\n    const attribute = schema.attributes[key] as AnyAttribute | undefined;\n\n    const newPath = { ...path };\n\n    newPath.raw = isNil(path.raw) ? key : `${path.raw}.${key}`;\n    newPath.rawWithIndices = isNil(path.rawWithIndices) ? key : `${path.rawWithIndices}.${key}`;\n\n    if (!isNil(attribute)) {\n      newPath.attribute = isNil(path.attribute) ? key : `${path.attribute}.${key}`;\n    }\n\n    // Visit the current attribute\n    const visitorOptions: VisitorOptions = {\n      data: copy,\n      schema,\n      key,\n      value: copy[key],\n      attribute,\n      path: newPath,\n      getModel,\n      parent,\n    };\n\n    await visitor(visitorOptions, visitorUtils);\n\n    // Extract the value for the current key (after calling the visitor)\n    const value = copy[key];\n\n    // Ignore Nil values or attributes\n    if (isNil(value) || isNil(attribute)) {\n      continue;\n    }\n\n    if (isRelationalAttribute(attribute)) {\n      parent = { schema, key, attribute, path: newPath };\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n      const method = isMorphRelation\n        ? traverseMorphRelationTarget\n        : traverseRelationTarget(getModel(attribute.target!));\n\n      if (isArray(value)) {\n        // Process array items in parallel with ordered error handling\n        copy[key] = await parallelWithOrderedErrors(\n          value.map((item, i) => {\n            const arrayPath = {\n              ...newPath,\n              rawWithIndices: isNil(newPath.rawWithIndices)\n                ? `${i}`\n                : `${newPath.rawWithIndices}.${i}`,\n            };\n            return method(visitor, arrayPath, item);\n          })\n        );\n      } else {\n        copy[key] = await method(visitor, newPath, value as Data);\n      }\n\n      continue;\n    }\n\n    if (isMediaAttribute(attribute)) {\n      parent = { schema, key, attribute, path: newPath };\n\n      if (isArray(value)) {\n        // Process media array items in parallel with ordered error handling\n        copy[key] = await parallelWithOrderedErrors(\n          value.map((item, i) => {\n            const arrayPath = {\n              ...newPath,\n              rawWithIndices: isNil(newPath.rawWithIndices)\n                ? `${i}`\n                : `${newPath.rawWithIndices}.${i}`,\n            };\n            return traverseMediaTarget(visitor, arrayPath, item);\n          })\n        );\n      } else {\n        copy[key] = await traverseMediaTarget(visitor, newPath, value as Data);\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      parent = { schema, key, attribute, path: newPath };\n      const targetSchema = getModel(attribute.component);\n\n      if (isArray(value)) {\n        // Process component array items in parallel with ordered error handling\n        copy[key] = await parallelWithOrderedErrors(\n          value.map((item, i) => {\n            const arrayPath = {\n              ...newPath,\n              rawWithIndices: isNil(newPath.rawWithIndices)\n                ? `${i}`\n                : `${newPath.rawWithIndices}.${i}`,\n            };\n            return traverseComponent(visitor, arrayPath, targetSchema, item);\n          })\n        );\n      } else {\n        copy[key] = await traverseComponent(visitor, newPath, targetSchema, value as Data);\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone' && isArray(value)) {\n      parent = { schema, key, attribute, path: newPath };\n\n      // Process dynamic zone items in parallel with ordered error handling\n      copy[key] = await parallelWithOrderedErrors(\n        value.map((item, i) => {\n          const arrayPath = {\n            ...newPath,\n            rawWithIndices: isNil(newPath.rawWithIndices)\n              ? `${i}`\n              : `${newPath.rawWithIndices}.${i}`,\n          };\n          return visitDynamicZoneEntry(visitor, arrayPath, item);\n        })\n      );\n\n      continue;\n    }\n  }\n\n  return copy;\n};\n\nconst createVisitorUtils = ({ data }: { data: Data }) => ({\n  remove(key: string) {\n    delete data[key];\n  },\n\n  set(key: string, value: Data) {\n    data[key] = value;\n  },\n});\n\nexport default curry(traverseEntity);\n"],"names":["parallelWithOrderedErrors","promises","results","Promise","allSettled","i","length","result","status","reason","map","r","value","traverseEntity","visitor","options","entity","path","raw","attribute","rawWithIndices","schema","getModel","parent","traverseMorphRelationTarget","entry","targetSchema","__type","traverseOptions","traverseRelationTarget","traverseMediaTarget","targetSchemaUID","traverseComponent","visitDynamicZoneEntry","__component","isObject","isNil","copy","clone","visitorUtils","createVisitorUtils","data","keys","Object","key","attributes","newPath","visitorOptions","isRelationalAttribute","isMorphRelation","relation","toLowerCase","startsWith","method","target","isArray","item","arrayPath","isMediaAttribute","type","component","remove","set","curry"],"mappings":"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"}