{"version":3,"file":"ai-localizations.js","sources":["../../../server/src/services/ai-localizations.ts"],"sourcesContent":["import type { Core, Modules, Schema, UID } from '@strapi/types';\nimport { traverseEntity } from '@strapi/utils';\nimport { getService } from '../utils';\n\nconst isLocalizedAttribute = (attribute: Schema.Attribute.Attribute | undefined): boolean => {\n  return (attribute?.pluginOptions as any)?.i18n?.localized === true;\n};\n\nconst UNSUPPORTED_ATTRIBUTE_TYPES: Schema.Attribute.Kind[] = [\n  'media',\n  'relation',\n  'boolean',\n  'enumeration',\n];\n\nconst IGNORED_FIELDS = [\n  'id',\n  'documentId',\n  'createdAt',\n  'updatedAt',\n  'publishedAt',\n  'locale',\n  'updatedBy',\n  'createdBy',\n  'localizations',\n];\n\n/**\n * Deep merge where target values take priority over source values.\n * Arrays are merged by index to align repeatable component / dynamic zone items.\n */\nconst deepMerge = (\n  source: Record<string, any>,\n  target: Record<string, any>\n): Record<string, any> => {\n  const result = { ...source };\n\n  for (const key of Object.keys(target)) {\n    const sourceVal = source[key];\n    const targetVal = target[key];\n\n    if (Array.isArray(targetVal) && Array.isArray(sourceVal)) {\n      result[key] = targetVal.map((item, i) => {\n        if (item && typeof item === 'object' && sourceVal[i] && typeof sourceVal[i] === 'object') {\n          return deepMerge(sourceVal[i], item);\n        }\n        return item;\n      });\n    } else if (\n      targetVal &&\n      typeof targetVal === 'object' &&\n      !Array.isArray(targetVal) &&\n      sourceVal &&\n      typeof sourceVal === 'object' &&\n      !Array.isArray(sourceVal)\n    ) {\n      result[key] = deepMerge(sourceVal, targetVal);\n    } else {\n      result[key] = targetVal;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Merges unsupported field types (media, boolean, enumeration, relation)\n * from a source document into the target data object.\n *\n * Uses traverseEntity to walk the source document and extract only unsupported fields,\n * then deep-merges the AI-translated target data on top so translated values take priority.\n */\nconst mergeUnsupportedFields = async (\n  targetData: Record<string, any>,\n  sourceDoc: Record<string, any> | null,\n  schema: Schema.Schema,\n  getModel: (uid: UID.Schema) => Schema.Schema | undefined\n): Promise<Record<string, any>> => {\n  if (!sourceDoc) {\n    return targetData;\n  }\n\n  // Track paths of relation/media fields so traverseEntity's recursion\n  // into those fields doesn't strip internal fields like `id` or `url`.\n  const preservedPaths = new Set<string>();\n\n  // Use traverseEntity to extract only unsupported fields from the source document.\n  // traverseEntity handles component and dynamic zone recursion automatically.\n  const unsupportedFieldsOnly = await traverseEntity(\n    ({ key, attribute, path }, { remove }) => {\n      // If we're inside a relation or media subtree, preserve everything.\n      // Use path-based prefix check instead of parent-based check because\n      // traverseEntity mutates `parent` across siblings at the same level,\n      // which would incorrectly mark sibling fields as inside a preserved subtree.\n      const isInsidePreservedSubtree =\n        path.raw && Array.from(preservedPaths).some((pp) => path.raw!.startsWith(`${pp}.`));\n      if (isInsidePreservedSubtree) {\n        preservedPaths.add(path.raw!);\n        return;\n      }\n\n      if (IGNORED_FIELDS.includes(key)) {\n        remove(key);\n        return;\n      }\n\n      // Keep fields with no schema attribute (e.g. __component in dynamic zones)\n      if (!attribute) {\n        return;\n      }\n\n      // Mark relation and media subtrees as preserved so their internal\n      // fields (id, url, etc.) are not removed during recursion\n      if (attribute.type === 'media' || attribute.type === 'relation') {\n        preservedPaths.add(path.raw!);\n        return;\n      }\n\n      // Keep other unsupported attribute types (boolean, enumeration)\n      if (UNSUPPORTED_ATTRIBUTE_TYPES.includes(attribute.type)) {\n        return;\n      }\n\n      // Keep components and dynamic zones â€” traverseEntity recurses into them\n      if (attribute.type === 'component' || attribute.type === 'dynamiczone') {\n        return;\n      }\n\n      // Remove supported (translatable) fields\n      remove(key);\n    },\n    { schema, getModel: getModel as (uid: string) => Schema.Schema },\n    sourceDoc\n  );\n\n  // Deep merge: AI-translated target takes priority over source unsupported fields\n  return deepMerge(unsupportedFieldsOnly, targetData);\n};\n\nconst createAILocalizationsService = ({ strapi }: { strapi: Core.Strapi }) => {\n  // TODO: add a helper function to get the AI server URL\n  const aiServerUrl = process.env.STRAPI_AI_URL || 'https://strapi-ai.apps.strapi.io';\n  const aiLocalizationJobsService = getService('ai-localization-jobs');\n\n  return {\n    // Async to avoid changing the signature later (there will be a db check in the future)\n    async isEnabled() {\n      // Check if user disabled AI features globally\n      const isAIEnabled = strapi.config.get('admin.ai.enabled', true);\n      if (!isAIEnabled) {\n        return false;\n      }\n\n      // Check if the user's license grants access to AI features\n      const hasAccess = strapi.ee.features.isEnabled('cms-ai');\n      if (!hasAccess) {\n        return false;\n      }\n\n      const settings = getService('settings');\n      const aiSettings = await settings.getSettings();\n      if (!aiSettings?.aiLocalizations) {\n        return false;\n      }\n\n      return true;\n    },\n\n    /**\n     * Checks if there are localizations that need to be generated for the given document,\n     * and if so, calls the AI service and saves the results to the database.\n     * Works for both single and collection types, on create and update.\n     */\n    async generateDocumentLocalizations({\n      model,\n      document,\n    }: {\n      model: UID.ContentType;\n      document: Modules.Documents.AnyDocument;\n    }) {\n      const isFeatureEnabled = await this.isEnabled();\n      if (!isFeatureEnabled) {\n        return;\n      }\n\n      const schema = strapi.getModel(model);\n      const localeService = getService('locales');\n\n      // No localizations needed for content types with i18n disabled\n      const isLocalizedContentType = getService('content-types').isLocalizedContentType(schema);\n      if (!isLocalizedContentType) {\n        return;\n      }\n\n      // Don't trigger localizations if the update is on a derived locale, only do it on the default\n      const defaultLocale = await localeService.getDefaultLocale();\n      if (document?.locale !== defaultLocale) {\n        return;\n      }\n\n      const documentId = document.documentId;\n\n      if (!documentId) {\n        strapi.log.warn(`AI Localizations: missing documentId for ${schema.uid}`);\n        return;\n      }\n\n      const localizedRoots = new Set();\n\n      const translateableContent = await traverseEntity(\n        ({ key, attribute, parent, path }, { remove }) => {\n          if (IGNORED_FIELDS.includes(key)) {\n            remove(key);\n            return;\n          }\n          const hasLocalizedOption = attribute && isLocalizedAttribute(attribute);\n          if (attribute && UNSUPPORTED_ATTRIBUTE_TYPES.includes(attribute.type)) {\n            remove(key);\n            return;\n          }\n\n          // If this field is localized, keep it (and mark as localized root if component/dz)\n          if (hasLocalizedOption) {\n            // If it's a component/dynamiczone, add to the set\n            if (['component', 'dynamiczone'].includes(attribute.type)) {\n              localizedRoots.add(path.raw);\n            }\n            return; // keep\n          }\n\n          if (parent && localizedRoots.has(parent.path.raw)) {\n            // If parent exists in the localized roots set, keep it\n            // If this is also a component/dz, propagate the localized root flag\n            if (['component', 'dynamiczone'].includes(attribute?.type ?? '')) {\n              localizedRoots.add(path.raw);\n            }\n            return; // keep\n          }\n\n          // Otherwise, remove the field\n          remove(key);\n        },\n        { schema, getModel: strapi.getModel.bind(strapi) },\n        document\n      );\n\n      if (Object.keys(translateableContent).length === 0) {\n        strapi.log.info(\n          `AI Localizations: no translatable content for ${schema.uid} document ${documentId}`\n        );\n        return;\n      }\n\n      const localesList = await localeService.find();\n      const targetLocales = localesList\n        .filter((l) => l.code !== document.locale)\n        .map((l) => l.code);\n\n      if (targetLocales.length === 0) {\n        strapi.log.info(\n          `AI Localizations: no target locales for ${schema.uid} document ${documentId}`\n        );\n        return;\n      }\n\n      await aiLocalizationJobsService.upsertJobForDocument({\n        contentType: model,\n        documentId,\n        sourceLocale: document.locale,\n        targetLocales,\n        status: 'processing',\n      });\n\n      let token: string;\n      try {\n        const tokenData = await strapi.get('ai').getAiToken();\n        token = tokenData.token;\n      } catch (error) {\n        await aiLocalizationJobsService.upsertJobForDocument({\n          documentId,\n          contentType: model,\n          sourceLocale: document.locale,\n          targetLocales,\n          status: 'failed',\n        });\n\n        throw new Error('Failed to retrieve AI token', {\n          cause: error instanceof Error ? error : undefined,\n        });\n      }\n\n      /**\n       * Provide a schema to the LLM so that we can give it instructions about how to handle each\n       * type of attribute. Only keep essential schema data to avoid cluttering the context.\n       * Ignore fields that don't need to be localized.\n       * TODO: also provide a schema of all the referenced components\n       */\n      const minimalContentTypeSchema = Object.fromEntries(\n        Object.entries(schema.attributes)\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          .filter(([_, attr]) => {\n            const isLocalized = isLocalizedAttribute(attr);\n            const isSupportedType = !UNSUPPORTED_ATTRIBUTE_TYPES.includes(attr.type);\n            return isLocalized && isSupportedType;\n          })\n          .map(([key, attr]) => {\n            const minimalAttribute = { type: attr.type };\n            if (attr.type === 'component') {\n              (\n                minimalAttribute as Schema.Attribute.Component<`${string}.${string}`, boolean>\n              ).repeatable = attr.repeatable ?? false;\n            }\n            return [key, minimalAttribute];\n          })\n      );\n\n      strapi.log.http('Contacting AI Server for localizations generation');\n      const response = await fetch(`${aiServerUrl}/i18n/generate-localizations`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${token}`,\n        },\n        body: JSON.stringify({\n          content: translateableContent,\n          sourceLocale: document.locale,\n          targetLocales,\n          contentTypeSchema: minimalContentTypeSchema,\n        }),\n      });\n\n      if (!response.ok) {\n        strapi.log.error(\n          `AI Localizations request failed: ${response.status} ${response.statusText}`\n        );\n\n        await aiLocalizationJobsService.upsertJobForDocument({\n          documentId,\n          contentType: model,\n          sourceLocale: document.locale,\n          targetLocales,\n          status: 'failed',\n        });\n\n        throw new Error(`AI Localizations request failed: ${response.statusText}`);\n      }\n\n      const aiResult = await response.json();\n\n      // Use populate-builder service for deep populate to fetch all nested fields\n      const populateBuilderService = strapi.plugin('content-manager').service('populate-builder');\n      // @ts-expect-error - populate-builder service returns a callable function\n      const deepPopulate = await populateBuilderService(model).populateDeep(Infinity).build();\n      const getModelBound = strapi.getModel.bind(strapi);\n\n      // Fetch the source document with all fields populated (for new locales that don't exist yet)\n      const sourceDocWithAllFields = await strapi.documents(model).findOne({\n        documentId,\n        locale: document.locale,\n        populate: deepPopulate,\n      });\n\n      try {\n        await Promise.all(\n          aiResult.localizations.map(async (localization: any) => {\n            const { content, locale } = localization;\n\n            // Fetch the existing derived locale document with all fields populated\n            const derivedDoc = await strapi.documents(model).findOne({\n              documentId,\n              locale,\n              populate: deepPopulate,\n            });\n\n            // Start with AI-translated content\n            let mergedData = structuredClone(content);\n\n            // Merge unsupported fields from existing derived doc (if exists) or source doc\n            // This preserves media, booleans, enumerations, and relations at all levels\n            const sourceForUnsupportedFields = derivedDoc || sourceDocWithAllFields;\n            mergedData = await mergeUnsupportedFields(\n              mergedData,\n              sourceForUnsupportedFields,\n              schema,\n              getModelBound\n            );\n\n            await strapi.documents(model).update({\n              documentId,\n              locale,\n              fields: [],\n              data: mergedData,\n            });\n\n            await aiLocalizationJobsService.upsertJobForDocument({\n              documentId,\n              contentType: model,\n              sourceLocale: document.locale,\n              targetLocales,\n              status: 'completed',\n            });\n          })\n        );\n      } catch (error) {\n        await aiLocalizationJobsService.upsertJobForDocument({\n          documentId,\n          contentType: model,\n          sourceLocale: document.locale,\n          targetLocales,\n          status: 'failed',\n        });\n        strapi.log.error('AI Localizations generation failed', error);\n      }\n    },\n    setupMiddleware() {\n      strapi.documents.use(async (context, next) => {\n        const result = await next();\n\n        // Only trigger for the allowed actions\n        if (!['create', 'update'].includes(context.action)) {\n          return result;\n        }\n\n        // Check if AI localizations are enabled before triggering\n        const isEnabled = await this.isEnabled();\n        if (!isEnabled) {\n          return result;\n        }\n\n        // Don't await since localizations should be done in the background without blocking the request\n        strapi\n          .plugin('i18n')\n          .service('ai-localizations')\n          .generateDocumentLocalizations({\n            model: context.contentType.uid,\n            document: result,\n          })\n          .catch((error: any) => {\n            strapi.log.error('AI Localizations generation failed', error);\n          });\n\n        return result;\n      });\n    },\n  };\n};\n\nexport { createAILocalizationsService, mergeUnsupportedFields };\n"],"names":["isLocalizedAttribute","attribute","pluginOptions","i18n","localized","UNSUPPORTED_ATTRIBUTE_TYPES","IGNORED_FIELDS","deepMerge","source","target","result","key","Object","keys","sourceVal","targetVal","Array","isArray","map","item","i","mergeUnsupportedFields","targetData","sourceDoc","schema","getModel","preservedPaths","Set","unsupportedFieldsOnly","traverseEntity","path","remove","isInsidePreservedSubtree","raw","from","some","pp","startsWith","add","includes","type","createAILocalizationsService","strapi","aiServerUrl","process","env","STRAPI_AI_URL","aiLocalizationJobsService","getService","isEnabled","isAIEnabled","config","get","hasAccess","ee","features","settings","aiSettings","getSettings","aiLocalizations","generateDocumentLocalizations","model","document","isFeatureEnabled","localeService","isLocalizedContentType","defaultLocale","getDefaultLocale","locale","documentId","log","warn","uid","localizedRoots","translateableContent","parent","hasLocalizedOption","has","bind","length","info","localesList","find","targetLocales","filter","l","code","upsertJobForDocument","contentType","sourceLocale","status","token","tokenData","getAiToken","error","Error","cause","undefined","minimalContentTypeSchema","fromEntries","entries","attributes","_","attr","isLocalized","isSupportedType","minimalAttribute","repeatable","http","response","fetch","method","headers","Authorization","body","JSON","stringify","content","contentTypeSchema","ok","statusText","aiResult","json","populateBuilderService","plugin","service","deepPopulate","populateDeep","Infinity","build","getModelBound","sourceDocWithAllFields","documents","findOne","populate","Promise","all","localizations","localization","derivedDoc","mergedData","structuredClone","sourceForUnsupportedFields","update","fields","data","setupMiddleware","use","context","next","action","catch"],"mappings":"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"}