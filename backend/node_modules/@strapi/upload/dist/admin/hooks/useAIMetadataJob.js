'use strict';

var React = require('react');
var strapiAdmin = require('@strapi/admin/strapi-admin');
var reactIntl = require('react-intl');
var reactQuery = require('react-query');
require('byte-size');
require('date-fns');
var getTrad = require('../utils/getTrad.js');
require('qs');
require('../utils/typeFromMime.js');
require('../utils/urlYupSchema.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

const fetchLatestJob = async (get)=>{
    try {
        const { data } = await get('/upload/actions/generate-ai-metadata/latest');
        return data;
    } catch  {
        // Return null on any error - UI treats this as "no active job"
        return null;
    }
};
const useAIMetadataJob = (options)=>{
    const { get } = strapiAdmin.useFetchClient();
    const { toggleNotification } = strapiAdmin.useNotification();
    const { formatMessage } = reactIntl.useIntl();
    const queryClient = reactQuery.useQueryClient();
    const enabled = options?.enabled ?? true;
    const [previousJobStatus, setPreviousJobStatus] = React__namespace.useState(null);
    // Single query with conditional polling
    const { data: job, refetch } = reactQuery.useQuery([
        'ai-metadata-latest-job'
    ], ()=>fetchLatestJob(get), {
        enabled,
        // Poll every second when job is processing
        refetchInterval: (data)=>{
            // If no data yet, don't poll
            if (!data) return false;
            // Poll while processing
            if (data.status === 'processing') {
                return 1000;
            }
            // Stop polling when completed or failed
            return false;
        },
        retry: false,
        refetchOnWindowFocus: false
    });
    const currentJobStatus = job?.status ?? null;
    // Detect status transitions and show notifications
    React__namespace.useEffect(()=>{
        if (!currentJobStatus) return;
        // Detect transition from active state to completed
        if (previousJobStatus === 'processing' && currentJobStatus === 'completed') {
            toggleNotification({
                type: 'success',
                message: formatMessage({
                    id: getTrad.getTrad('settings.form.aiMetadata.job-completed'),
                    defaultMessage: 'Successfully generated metadata'
                })
            });
            // Invalidate metadata count query to refresh the count
            queryClient.invalidateQueries([
                'ai-metadata-count'
            ]);
        }
        // Detect transition from active state to failed
        if (previousJobStatus === 'processing' && currentJobStatus === 'failed') {
            toggleNotification({
                type: 'danger',
                message: formatMessage({
                    id: getTrad.getTrad('settings.form.aiMetadata.job-failed'),
                    defaultMessage: 'Failed to generate metadata. Please try again.'
                })
            });
        }
        // Update previous status if it changed
        if (previousJobStatus !== currentJobStatus) {
            setPreviousJobStatus(currentJobStatus);
        }
    }, [
        currentJobStatus,
        previousJobStatus,
        toggleNotification,
        formatMessage,
        queryClient
    ]);
    return {
        data: job,
        refetch
    };
};

exports.useAIMetadataJob = useAIMetadataJob;
//# sourceMappingURL=useAIMetadataJob.js.map
