{"version":3,"file":"ai-metadata.mjs","sources":["../../../server/src/services/ai-metadata.ts"],"sourcesContent":["import type { Core } from '@strapi/types';\nimport { z } from 'zod';\nimport { InputFile, File } from '../types';\nimport { Settings } from '../controllers/validation/admin/settings';\nimport { getService } from '../utils';\nimport { buildFormDataFromFiles } from '../utils/images';\n\n/**\n * Supported image types for AI metadata generation\n * @see https://ai.google.dev/gemini-api/docs/image-understanding\n */\nconst SUPPORTED_IMAGE_TYPES = [\n  'image/png',\n  'image/jpeg',\n  'image/webp',\n  'image/heic',\n  'image/heif',\n] as const;\n\nconst createAIMetadataService = ({ strapi }: { strapi: Core.Strapi }) => {\n  const aiServerUrl = process.env.STRAPI_AI_URL || 'https://strapi-ai.apps.strapi.io';\n\n  return {\n    async isEnabled() {\n      // Check if user disabled AI features globally\n      const isAIEnabled = strapi.config.get('admin.ai.enabled', true);\n      if (!isAIEnabled) {\n        return false;\n      }\n\n      // Check if the user's license grants access to AI features\n      const hasAccess = strapi.ee.features.isEnabled('cms-ai');\n      if (!hasAccess) {\n        return false;\n      }\n\n      // Check if feature is specifically enabled, defaulting to true\n      const settings: Settings = await strapi.plugin('upload').service('upload').getSettings();\n      const aiMetadata: boolean = settings.aiMetadata ?? true;\n\n      return aiMetadata;\n    },\n\n    async countImagesWithoutMetadata() {\n      const imagesWithoutMetadataCountPromise = strapi.db.query('plugin::upload.file').count({\n        where: {\n          mime: {\n            $in: SUPPORTED_IMAGE_TYPES,\n          },\n          $or: [\n            { alternativeText: { $null: true } },\n            { alternativeText: '' },\n            { caption: { $null: true } },\n            { caption: '' },\n          ],\n        },\n      });\n\n      const totalImagesPromise = strapi.db.query('plugin::upload.file').count({\n        where: {\n          mime: {\n            $in: SUPPORTED_IMAGE_TYPES,\n          },\n        },\n      });\n\n      const [imagesWithoutMetadataCount, totalImages] = await Promise.all([\n        imagesWithoutMetadataCountPromise,\n        totalImagesPromise,\n      ]);\n\n      return { imagesWithoutMetadataCount, totalImages };\n    },\n\n    /**\n     * Update files with AI-generated metadata\n     * Shared logic used by both upload flow and retroactive processing\n     */\n    async updateFilesWithAIMetadata(\n      files: File[],\n      metadataResults: Array<{ altText: string; caption: string } | null>,\n      user: { id: string | number }\n    ) {\n      const uploadService = strapi.plugin('upload').service('upload');\n\n      await Promise.all(\n        files.map(async (file, index) => {\n          const aiMetadata = metadataResults[index];\n          if (aiMetadata) {\n            // Only update fields that are missing (null or empty string)\n            const updateData: { alternativeText?: string; caption?: string } = {};\n\n            if (!file.alternativeText || file.alternativeText === '') {\n              updateData.alternativeText = aiMetadata.altText;\n            }\n\n            if (!file.caption || file.caption === '') {\n              updateData.caption = aiMetadata.caption;\n            }\n\n            // Only update if there are fields to update\n            if (Object.keys(updateData).length > 0) {\n              await uploadService.updateFileInfo(file.id, updateData, { user });\n\n              // Update in-memory file object (needed for upload flow response)\n              if (updateData.alternativeText !== undefined) {\n                file.alternativeText = updateData.alternativeText;\n              }\n              if (updateData.caption !== undefined) {\n                file.caption = updateData.caption;\n              }\n            }\n          }\n        })\n      );\n    },\n\n    /**\n     * Process existing files with job tracking for progress updates\n     */\n    async processExistingFiles(jobId: number, user: { id: string | number }): Promise<void> {\n      const jobService = getService('aiMetadataJobs');\n\n      try {\n        // Mark as processing\n        await jobService.updateJob(jobId, { status: 'processing' });\n\n        // Query all images without metadata\n        const files: File[] = await strapi.db.query('plugin::upload.file').findMany({\n          where: {\n            mime: {\n              $in: SUPPORTED_IMAGE_TYPES,\n            },\n            $or: [\n              { alternativeText: { $null: true } },\n              { alternativeText: '' },\n              { caption: { $null: true } },\n              { caption: '' },\n            ],\n          },\n        });\n\n        if (files.length === 0) {\n          await jobService.updateJob(jobId, {\n            status: 'completed',\n            completedAt: new Date(),\n          });\n          return;\n        }\n\n        // Process all files at once\n        const metadataResults = await this.processFiles(files);\n        await this.updateFilesWithAIMetadata(files, metadataResults, user);\n\n        // Mark as completed\n        await jobService.updateJob(jobId, {\n          status: 'completed',\n          completedAt: new Date(),\n        });\n      } catch (error) {\n        strapi.log.error('AI metadata job failed', {\n          jobId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n\n        await jobService.updateJob(jobId, {\n          status: 'failed',\n          completedAt: new Date(),\n        });\n      }\n    },\n\n    /**\n     * Processes provided files for AI metadata generation\n     */\n    async processFiles(files: File[]): Promise<Array<{ altText: string; caption: string } | null>> {\n      if (!(await this.isEnabled()) || !aiServerUrl) {\n        throw new Error('AI Metadata service is not enabled');\n      }\n\n      // Filter for image files only and track their original positions\n      // We need to maintain the original indices so we can map AI results back correctly\n      const imageFiles = files\n        .map((file, index) => ({ file, originalIndex: index }))\n        .filter(({ file }) => file.mime?.startsWith('image/'));\n\n      // Convert filtered image files to InputFile format (uses thumbnails when available)\n      const imageInputFiles = imageFiles.map(({ file }) => {\n        const thumbnail = (file.formats as any)?.thumbnail;\n        return {\n          filepath: thumbnail?.url || file.url || '',\n          mimetype: file.mime,\n          originalFilename: file.name,\n          size: thumbnail?.size || file.size,\n          provider: file.provider,\n        } as InputFile;\n      });\n\n      // If no image files, return sparse array with all nulls to avoid calling the AI server\n      // This maintains the same array length as input files for proper index alignment\n      if (imageFiles.length === 0) {\n        return new Array(files.length).fill(null);\n      }\n\n      const formData = await buildFormDataFromFiles(\n        imageInputFiles,\n        strapi.config.get('server.absoluteUrl'),\n        strapi.log\n      );\n\n      let token: string;\n      try {\n        const tokenData = await strapi.get('ai').getAiToken();\n        token = tokenData.token;\n      } catch (error) {\n        throw new Error('Failed to retrieve AI token', {\n          cause: error instanceof Error ? error : undefined,\n        });\n      }\n\n      strapi.log.http('Contacting AI Server for media metadata generation', {\n        aiServerUrl,\n        imageCount: imageFiles.length,\n      });\n\n      const res = await fetch(`${aiServerUrl}/media-library/generate-metadata`, {\n        method: 'POST',\n        body: formData,\n        headers: {\n          Authorization: `Bearer ${token}`,\n        },\n      });\n\n      if (!res.ok) {\n        const errorText = await res.text();\n        throw Error(`AI metadata generation failed`, { cause: errorText });\n      }\n\n      const responseSchema = z.object({\n        results: z.array(\n          z.object({\n            altText: z.string(),\n            caption: z.string(),\n          })\n        ),\n      });\n\n      const { results } = responseSchema.parse(await res.json());\n      strapi.log.http(`AI generated metadata successfully for ${results.length} files`);\n\n      // Create sparse array with results at original indices\n      // Example: files=[img1, pdf, img2] -> imageFiles=[{img1, index:0}, {img2, index:2}]\n      // AI results=[meta1, meta2] -> sparse=[meta1, null, meta2]\n      // This ensures metadata[i] corresponds to files[i], with null for non-images\n      return imageFiles.reduce((sparseResults, { originalIndex }, resultIndex) => {\n        sparseResults[originalIndex] = results[resultIndex];\n        return sparseResults;\n      }, new Array(files.length).fill(null));\n    },\n  };\n};\n\nexport { createAIMetadataService };\n"],"names":["SUPPORTED_IMAGE_TYPES","createAIMetadataService","strapi","aiServerUrl","process","env","STRAPI_AI_URL","isEnabled","isAIEnabled","config","get","hasAccess","ee","features","settings","plugin","service","getSettings","aiMetadata","countImagesWithoutMetadata","imagesWithoutMetadataCountPromise","db","query","count","where","mime","$in","$or","alternativeText","$null","caption","totalImagesPromise","imagesWithoutMetadataCount","totalImages","Promise","all","updateFilesWithAIMetadata","files","metadataResults","user","uploadService","map","file","index","updateData","altText","Object","keys","length","updateFileInfo","id","undefined","processExistingFiles","jobId","jobService","getService","updateJob","status","findMany","completedAt","Date","processFiles","error","log","Error","message","String","imageFiles","originalIndex","filter","startsWith","imageInputFiles","thumbnail","formats","filepath","url","mimetype","originalFilename","name","size","provider","Array","fill","formData","buildFormDataFromFiles","token","tokenData","getAiToken","cause","http","imageCount","res","fetch","method","body","headers","Authorization","ok","errorText","text","responseSchema","z","object","results","array","string","parse","json","reduce","sparseResults","resultIndex"],"mappings":";;;;AAOA;;;AAGC,IACD,MAAMA,qBAAwB,GAAA;AAC5B,IAAA,WAAA;AACA,IAAA,YAAA;AACA,IAAA,YAAA;AACA,IAAA,YAAA;AACA,IAAA;AACD,CAAA;AAED,MAAMC,uBAA0B,GAAA,CAAC,EAAEC,MAAM,EAA2B,GAAA;AAClE,IAAA,MAAMC,WAAcC,GAAAA,OAAAA,CAAQC,GAAG,CAACC,aAAa,IAAI,kCAAA;IAEjD,OAAO;QACL,MAAMC,SAAAA,CAAAA,GAAAA;;AAEJ,YAAA,MAAMC,cAAcN,MAAOO,CAAAA,MAAM,CAACC,GAAG,CAAC,kBAAoB,EAAA,IAAA,CAAA;AAC1D,YAAA,IAAI,CAACF,WAAa,EAAA;gBAChB,OAAO,KAAA;AACT;;AAGA,YAAA,MAAMG,YAAYT,MAAOU,CAAAA,EAAE,CAACC,QAAQ,CAACN,SAAS,CAAC,QAAA,CAAA;AAC/C,YAAA,IAAI,CAACI,SAAW,EAAA;gBACd,OAAO,KAAA;AACT;;YAGA,MAAMG,QAAAA,GAAqB,MAAMZ,MAAOa,CAAAA,MAAM,CAAC,QAAUC,CAAAA,CAAAA,OAAO,CAAC,QAAA,CAAA,CAAUC,WAAW,EAAA;YACtF,MAAMC,UAAAA,GAAsBJ,QAASI,CAAAA,UAAU,IAAI,IAAA;YAEnD,OAAOA,UAAAA;AACT,SAAA;QAEA,MAAMC,0BAAAA,CAAAA,GAAAA;YACJ,MAAMC,iCAAAA,GAAoClB,OAAOmB,EAAE,CAACC,KAAK,CAAC,qBAAA,CAAA,CAAuBC,KAAK,CAAC;gBACrFC,KAAO,EAAA;oBACLC,IAAM,EAAA;wBACJC,GAAK1B,EAAAA;AACP,qBAAA;oBACA2B,GAAK,EAAA;AACH,wBAAA;4BAAEC,eAAiB,EAAA;gCAAEC,KAAO,EAAA;AAAK;AAAE,yBAAA;AACnC,wBAAA;4BAAED,eAAiB,EAAA;AAAG,yBAAA;AACtB,wBAAA;4BAAEE,OAAS,EAAA;gCAAED,KAAO,EAAA;AAAK;AAAE,yBAAA;AAC3B,wBAAA;4BAAEC,OAAS,EAAA;AAAG;AACf;AACH;AACF,aAAA,CAAA;YAEA,MAAMC,kBAAAA,GAAqB7B,OAAOmB,EAAE,CAACC,KAAK,CAAC,qBAAA,CAAA,CAAuBC,KAAK,CAAC;gBACtEC,KAAO,EAAA;oBACLC,IAAM,EAAA;wBACJC,GAAK1B,EAAAA;AACP;AACF;AACF,aAAA,CAAA;AAEA,YAAA,MAAM,CAACgC,0BAA4BC,EAAAA,WAAAA,CAAY,GAAG,MAAMC,OAAAA,CAAQC,GAAG,CAAC;AAClEf,gBAAAA,iCAAAA;AACAW,gBAAAA;AACD,aAAA,CAAA;YAED,OAAO;AAAEC,gBAAAA,0BAAAA;AAA4BC,gBAAAA;AAAY,aAAA;AACnD,SAAA;AAEA;;;AAGC,QACD,MAAMG,yBACJC,CAAAA,CAAAA,KAAa,EACbC,eAAmE,EACnEC,IAA6B,EAAA;AAE7B,YAAA,MAAMC,gBAAgBtC,MAAOa,CAAAA,MAAM,CAAC,QAAA,CAAA,CAAUC,OAAO,CAAC,QAAA,CAAA;AAEtD,YAAA,MAAMkB,QAAQC,GAAG,CACfE,MAAMI,GAAG,CAAC,OAAOC,IAAMC,EAAAA,KAAAA,GAAAA;gBACrB,MAAMzB,UAAAA,GAAaoB,eAAe,CAACK,KAAM,CAAA;AACzC,gBAAA,IAAIzB,UAAY,EAAA;;AAEd,oBAAA,MAAM0B,aAA6D,EAAC;AAEpE,oBAAA,IAAI,CAACF,IAAKd,CAAAA,eAAe,IAAIc,IAAKd,CAAAA,eAAe,KAAK,EAAI,EAAA;wBACxDgB,UAAWhB,CAAAA,eAAe,GAAGV,UAAAA,CAAW2B,OAAO;AACjD;AAEA,oBAAA,IAAI,CAACH,IAAKZ,CAAAA,OAAO,IAAIY,IAAKZ,CAAAA,OAAO,KAAK,EAAI,EAAA;wBACxCc,UAAWd,CAAAA,OAAO,GAAGZ,UAAAA,CAAWY,OAAO;AACzC;;AAGA,oBAAA,IAAIgB,OAAOC,IAAI,CAACH,UAAYI,CAAAA,CAAAA,MAAM,GAAG,CAAG,EAAA;AACtC,wBAAA,MAAMR,cAAcS,cAAc,CAACP,IAAKQ,CAAAA,EAAE,EAAEN,UAAY,EAAA;AAAEL,4BAAAA;AAAK,yBAAA,CAAA;;wBAG/D,IAAIK,UAAAA,CAAWhB,eAAe,KAAKuB,SAAW,EAAA;4BAC5CT,IAAKd,CAAAA,eAAe,GAAGgB,UAAAA,CAAWhB,eAAe;AACnD;wBACA,IAAIgB,UAAAA,CAAWd,OAAO,KAAKqB,SAAW,EAAA;4BACpCT,IAAKZ,CAAAA,OAAO,GAAGc,UAAAA,CAAWd,OAAO;AACnC;AACF;AACF;AACF,aAAA,CAAA,CAAA;AAEJ,SAAA;AAEA;;AAEC,QACD,MAAMsB,oBAAAA,CAAAA,CAAqBC,KAAa,EAAEd,IAA6B,EAAA;AACrE,YAAA,MAAMe,aAAaC,UAAW,CAAA,gBAAA,CAAA;YAE9B,IAAI;;gBAEF,MAAMD,UAAAA,CAAWE,SAAS,CAACH,KAAO,EAAA;oBAAEI,MAAQ,EAAA;AAAa,iBAAA,CAAA;;gBAGzD,MAAMpB,KAAAA,GAAgB,MAAMnC,MAAOmB,CAAAA,EAAE,CAACC,KAAK,CAAC,qBAAuBoC,CAAAA,CAAAA,QAAQ,CAAC;oBAC1ElC,KAAO,EAAA;wBACLC,IAAM,EAAA;4BACJC,GAAK1B,EAAAA;AACP,yBAAA;wBACA2B,GAAK,EAAA;AACH,4BAAA;gCAAEC,eAAiB,EAAA;oCAAEC,KAAO,EAAA;AAAK;AAAE,6BAAA;AACnC,4BAAA;gCAAED,eAAiB,EAAA;AAAG,6BAAA;AACtB,4BAAA;gCAAEE,OAAS,EAAA;oCAAED,KAAO,EAAA;AAAK;AAAE,6BAAA;AAC3B,4BAAA;gCAAEC,OAAS,EAAA;AAAG;AACf;AACH;AACF,iBAAA,CAAA;gBAEA,IAAIO,KAAAA,CAAMW,MAAM,KAAK,CAAG,EAAA;oBACtB,MAAMM,UAAAA,CAAWE,SAAS,CAACH,KAAO,EAAA;wBAChCI,MAAQ,EAAA,WAAA;AACRE,wBAAAA,WAAAA,EAAa,IAAIC,IAAAA;AACnB,qBAAA,CAAA;AACA,oBAAA;AACF;;AAGA,gBAAA,MAAMtB,eAAkB,GAAA,MAAM,IAAI,CAACuB,YAAY,CAACxB,KAAAA,CAAAA;AAChD,gBAAA,MAAM,IAAI,CAACD,yBAAyB,CAACC,OAAOC,eAAiBC,EAAAA,IAAAA,CAAAA;;gBAG7D,MAAMe,UAAAA,CAAWE,SAAS,CAACH,KAAO,EAAA;oBAChCI,MAAQ,EAAA,WAAA;AACRE,oBAAAA,WAAAA,EAAa,IAAIC,IAAAA;AACnB,iBAAA,CAAA;AACF,aAAA,CAAE,OAAOE,KAAO,EAAA;AACd5D,gBAAAA,MAAAA,CAAO6D,GAAG,CAACD,KAAK,CAAC,wBAA0B,EAAA;AACzCT,oBAAAA,KAAAA;AACAS,oBAAAA,KAAAA,EAAOA,KAAiBE,YAAAA,KAAAA,GAAQF,KAAMG,CAAAA,OAAO,GAAGC,MAAOJ,CAAAA,KAAAA;AACzD,iBAAA,CAAA;gBAEA,MAAMR,UAAAA,CAAWE,SAAS,CAACH,KAAO,EAAA;oBAChCI,MAAQ,EAAA,QAAA;AACRE,oBAAAA,WAAAA,EAAa,IAAIC,IAAAA;AACnB,iBAAA,CAAA;AACF;AACF,SAAA;AAEA;;QAGA,MAAMC,cAAaxB,KAAa,EAAA;AAC9B,YAAA,IAAI,CAAE,MAAM,IAAI,CAAC9B,SAAS,EAAA,IAAO,CAACJ,WAAa,EAAA;AAC7C,gBAAA,MAAM,IAAI6D,KAAM,CAAA,oCAAA,CAAA;AAClB;;;AAIA,YAAA,MAAMG,aAAa9B,KAChBI,CAAAA,GAAG,CAAC,CAACC,IAAAA,EAAMC,SAAW;AAAED,oBAAAA,IAAAA;oBAAM0B,aAAezB,EAAAA;iBAAM,CAAA,CAAA,CACnD0B,MAAM,CAAC,CAAC,EAAE3B,IAAI,EAAE,GAAKA,IAAAA,CAAKjB,IAAI,EAAE6C,UAAW,CAAA,QAAA,CAAA,CAAA;;AAG9C,YAAA,MAAMC,kBAAkBJ,UAAW1B,CAAAA,GAAG,CAAC,CAAC,EAAEC,IAAI,EAAE,GAAA;gBAC9C,MAAM8B,SAAAA,GAAa9B,IAAK+B,CAAAA,OAAO,EAAUD,SAAAA;gBACzC,OAAO;AACLE,oBAAAA,QAAAA,EAAUF,SAAWG,EAAAA,GAAAA,IAAOjC,IAAKiC,CAAAA,GAAG,IAAI,EAAA;AACxCC,oBAAAA,QAAAA,EAAUlC,KAAKjB,IAAI;AACnBoD,oBAAAA,gBAAAA,EAAkBnC,KAAKoC,IAAI;oBAC3BC,IAAMP,EAAAA,SAAAA,EAAWO,IAAQrC,IAAAA,IAAAA,CAAKqC,IAAI;AAClCC,oBAAAA,QAAAA,EAAUtC,KAAKsC;AACjB,iBAAA;AACF,aAAA,CAAA;;;YAIA,IAAIb,UAAAA,CAAWnB,MAAM,KAAK,CAAG,EAAA;AAC3B,gBAAA,OAAO,IAAIiC,KAAM5C,CAAAA,KAAAA,CAAMW,MAAM,CAAA,CAAEkC,IAAI,CAAC,IAAA,CAAA;AACtC;YAEA,MAAMC,QAAAA,GAAW,MAAMC,sBAAAA,CACrBb,eACArE,EAAAA,MAAAA,CAAOO,MAAM,CAACC,GAAG,CAAC,oBAClBR,CAAAA,EAAAA,MAAAA,CAAO6D,GAAG,CAAA;YAGZ,IAAIsB,KAAAA;YACJ,IAAI;AACF,gBAAA,MAAMC,YAAY,MAAMpF,MAAAA,CAAOQ,GAAG,CAAC,MAAM6E,UAAU,EAAA;AACnDF,gBAAAA,KAAAA,GAAQC,UAAUD,KAAK;AACzB,aAAA,CAAE,OAAOvB,KAAO,EAAA;gBACd,MAAM,IAAIE,MAAM,6BAA+B,EAAA;oBAC7CwB,KAAO1B,EAAAA,KAAAA,YAAiBE,QAAQF,KAAQX,GAAAA;AAC1C,iBAAA,CAAA;AACF;AAEAjD,YAAAA,MAAAA,CAAO6D,GAAG,CAAC0B,IAAI,CAAC,oDAAsD,EAAA;AACpEtF,gBAAAA,WAAAA;AACAuF,gBAAAA,UAAAA,EAAYvB,WAAWnB;AACzB,aAAA,CAAA;AAEA,YAAA,MAAM2C,MAAM,MAAMC,KAAAA,CAAM,GAAGzF,WAAY,CAAA,gCAAgC,CAAC,EAAE;gBACxE0F,MAAQ,EAAA,MAAA;gBACRC,IAAMX,EAAAA,QAAAA;gBACNY,OAAS,EAAA;oBACPC,aAAe,EAAA,CAAC,OAAO,EAAEX,KAAO,CAAA;AAClC;AACF,aAAA,CAAA;YAEA,IAAI,CAACM,GAAIM,CAAAA,EAAE,EAAE;gBACX,MAAMC,SAAAA,GAAY,MAAMP,GAAAA,CAAIQ,IAAI,EAAA;AAChC,gBAAA,MAAMnC,KAAM,CAAA,CAAC,6BAA6B,CAAC,EAAE;oBAAEwB,KAAOU,EAAAA;AAAU,iBAAA,CAAA;AAClE;YAEA,MAAME,cAAAA,GAAiBC,CAAEC,CAAAA,MAAM,CAAC;AAC9BC,gBAAAA,OAAAA,EAASF,CAAEG,CAAAA,KAAK,CACdH,CAAAA,CAAEC,MAAM,CAAC;AACPzD,oBAAAA,OAAAA,EAASwD,EAAEI,MAAM,EAAA;AACjB3E,oBAAAA,OAAAA,EAASuE,EAAEI,MAAM;AACnB,iBAAA,CAAA;AAEJ,aAAA,CAAA;YAEA,MAAM,EAAEF,OAAO,EAAE,GAAGH,eAAeM,KAAK,CAAC,MAAMf,GAAAA,CAAIgB,IAAI,EAAA,CAAA;YACvDzG,MAAO6D,CAAAA,GAAG,CAAC0B,IAAI,CAAC,CAAC,uCAAuC,EAAEc,OAAQvD,CAAAA,MAAM,CAAC,MAAM,CAAC,CAAA;;;;;YAMhF,OAAOmB,UAAAA,CAAWyC,MAAM,CAAC,CAACC,eAAe,EAAEzC,aAAa,EAAE,EAAE0C,WAAAA,GAAAA;AAC1DD,gBAAAA,aAAa,CAACzC,aAAAA,CAAc,GAAGmC,OAAO,CAACO,WAAY,CAAA;gBACnD,OAAOD,aAAAA;AACT,aAAA,EAAG,IAAI5B,KAAM5C,CAAAA,KAAAA,CAAMW,MAAM,CAAA,CAAEkC,IAAI,CAAC,IAAA,CAAA,CAAA;AAClC;AACF,KAAA;AACF;;;;"}